# -*- coding: utf-8 -*-
"""predict_and_plot_moving_average.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wb6UhTV4UOYmnPJZzx4npb2NfB1mXEpK
"""

import ee
import numpy as np
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, r2_score
import geemap
import csv

ee.Authenticate()

# Initialize the library.
ee.Initialize(project = 'crypto-pulsar-418018')

# Declare datasets to be used
irrigation_dataset = ee.Image("USGS/GFSAD1000_V1")
climate_dataset = ee.ImageCollection('NASA/ORNL/DAYMET_V4')
crop_dataset = ee.ImageCollection('USDA/NASS/CDL')
elevation_dataset = (ee.Image("CGIAR/SRTM90_V4"))

# Define columns within the datasets to be used
selected_variables_irrigation = ['landcover']
irrigation_data = irrigation_dataset.select(selected_variables_irrigation)

selected_variables_climate = ['prcp', 'tmin', 'tmax']
climate_data = climate_dataset.select(selected_variables_climate)

"""## Functions"""

def get_irrigation_level (xy_point):

  irrigation_level = irrigation_data.reduceRegion(reducer=ee.Reducer.first(), geometry = xy_point)
  return irrigation_level.getInfo()['landcover']

# Helper methods
def __get_day_values(data, date, xy_point):
    day_data = data.filterDate(date, date.advance(1, 'day'))

    # Check if the collection is empty
    if day_data.size().getInfo() == 0:
        print(f"No data available for {date.format().getInfo()}")
        return None

    # Proceed with reduceRegion since we now know there is at least one image
    first_image = day_data.first()
    day_values = first_image.reduceRegion(reducer=ee.Reducer.first(), geometry=xy_point)

    # Return the values as a dictionary
    return day_values.getInfo()

def get_climate_data (xy_point, date_str):
    date = ee.Date(date_str)
    daily_value = __get_day_values(climate_data, date, xy_point)
    # Return the values as a dictionary, containing dayl, prcp, tmax, tmin
    return daily_value

def get_crop_data (xy_point, date_str):
    date = ee.Date(date_str)
    day_value = __get_day_values(crop_dataset, date, xy_point)
    # Return the qualitative value
    return day_value['cropland']

def get_elevation_data(xy_point):
    elevation_for_point = elevation_dataset.reduceRegion(reducer=ee.Reducer.first(), geometry=xy_point)
    # Return number. The unit is meter
    return elevation_for_point.getInfo()['elevation']

"""## Combined Function"""

def get_results(coordinates):
    xy_point = ee.Geometry.Point(coordinates)

    irrigation_result = get_irrigation_level(xy_point)
    climate_result = get_climate_data(xy_point)
    crop_result = get_crop_data(xy_point)
    elevation_result = get_elevation_data(xy_point)

    result = {
        "irrigation_result": irrigation_result,
        "tmin": climate_result['tmin'],
        "tmax": climate_result["tmax"],
        "prcp": climate_result["prcp"],
        "cropland": crop_result,
        "elevation_result": elevation_result
    }
    print(result)
    return result

point = [-112.087198, 33.037128]
xy_point = ee.Geometry.Point(point)

data = []

for year in range(1997, 2023):
    # crop_result = get_crop_data(xy_point, date_str)
    for month in [1, 4, 7, 10]:
        date_str = f'{str(year)}-{str(month)}-15'
        climate_result = get_climate_data(xy_point, date_str)

        # Combine the year, climate result, and crop result into a dictionary
        year_result = {
          'date': date_str,
          'climate': climate_result
        }

        # Append the combined result to the results list
        data.append(year_result)
    print(year)

data
data = data[:-1]
data

from sklearn.linear_model import LinearRegression
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime

# Assuming 'data' is your full dataset

# Convert date strings to ordinal numbers
date_to_ordinal = lambda date: datetime.strptime(date, '%Y-%m-%d').toordinal()
X = np.array([[date_to_ordinal(entry['date'])] for entry in data])
y_tmin = np.array([entry['climate']['tmin'] for entry in data])
y_tmax = np.array([entry['climate']['tmax'] for entry in data])
y_prcp = np.array([entry['climate']['prcp'] for entry in data])

# Train models for each target
model_tmin = LinearRegression().fit(X, y_tmin)
model_tmax = LinearRegression().fit(X, y_tmax)
model_prcp = LinearRegression().fit(X, y_prcp)

# Prepare future dates (this part is simplified, you might want to specify exact future dates)
future_dates = [datetime(year, month, 15).toordinal()
                for year in range(2024, 2029)
                for month in [1, 4, 7, 10]]
future_years = np.array(future_dates).reshape(-1, 1)

# Predict the climate variables for the next 5 years
predictions_tmin = model_tmin.predict(future_years)
predictions_tmax = model_tmax.predict(future_years)
predictions_prcp = model_prcp.predict(future_years)

# Plotting (this part remains largely unchanged)
plt.figure(figsize=(14, 8))

import matplotlib.dates as mdates

# Convert the ordinal dates back to datetime objects for plotting
X_dates = [datetime.fromordinal(int(ox)) for ox in X.flatten()]
future_dates_dt = [datetime.fromordinal(fd) for fd in future_dates]

# Prepare the figure with three subplots for Tmin, Tmax, and Prcp
plt.figure(figsize=(14, 10))

# TMIN Plot
plt.subplot(3, 1, 1)
plt.plot(X_dates, y_tmin, label='Historical Tmin', marker='o', linestyle='-')
plt.plot(future_dates_dt, predictions_tmin, label='Predicted Tmin', marker='x', linestyle='--')
plt.ylabel('Tmin (°C)')
plt.legend()
plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))

# TMAX Plot
plt.subplot(3, 1, 2)
plt.plot(X_dates, y_tmax, label='Historical Tmax', marker='o', linestyle='-')
plt.plot(future_dates_dt, predictions_tmax, label='Predicted Tmax', marker='x', linestyle='--')
plt.ylabel('Tmax (°C)')
plt.legend()
plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))

# PRCP Plot
plt.subplot(3, 1, 3)
plt.plot(X_dates, y_prcp, label='Historical Prcp', marker='o', linestyle='-')
plt.plot(future_dates_dt, predictions_prcp, label='Predicted Prcp', marker='x', linestyle='--')
plt.xlabel('Date')
plt.ylabel('Prcp (mm)')
plt.legend()
plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))

# Improve spacing and layout
plt.tight_layout()
plt.show()

# the months are [1, 4, 7, 10]

from sklearn.linear_model import LinearRegression
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime

# Assuming 'data' is your full dataset

# Group data by year and calculate the average for each climate variable
grouped_data = {}
for entry in data:
    year = datetime.strptime(entry['date'], '%Y-%m-%d').year
    if year not in grouped_data:
        grouped_data[year] = {'tmin': [], 'tmax': [], 'prcp': []}
    grouped_data[year]['tmin'].append(entry['climate']['tmin'])
    grouped_data[year]['tmax'].append(entry['climate']['tmax'])
    grouped_data[year]['prcp'].append(entry['climate']['prcp'])

# Calculate the average of each climate variable per year
average_data = {
    year: {
        'tmin': np.mean(values['tmin']),
        'tmax': np.mean(values['tmax']),
        'prcp': np.mean(values['prcp']),
    }
    for year, values in grouped_data.items()
}

# Prepare the dataset for modeling
X_years = np.array(list(average_data.keys())).reshape(-1, 1)
y_tmin_avg = np.array([values['tmin'] for values in average_data.values()])
y_tmax_avg = np.array([values['tmax'] for values in average_data.values()])
y_prcp_avg = np.array([values['prcp'] for values in average_data.values()])

# Train models for each target
model_tmin_avg = LinearRegression().fit(X_years, y_tmin_avg)
model_tmax_avg = LinearRegression().fit(X_years, y_tmax_avg)
model_prcp_avg = LinearRegression().fit(X_years, y_prcp_avg)

# Predict the climate variables for the next 5 years
future_years = np.array(range(2024, 2029)).reshape(-1, 1)
predictions_tmin_avg = model_tmin_avg.predict(future_years)
predictions_tmax_avg = model_tmax_avg.predict(future_years)
predictions_prcp_avg = model_prcp_avg.predict(future_years)

# Plotting
plt.figure(figsize=(14, 10))

# Plot the average Tmin
plt.subplot(3, 1, 1)
plt.plot(X_years, y_tmin_avg, label='Average Historical Tmin', marker='o')
plt.plot(future_years, predictions_tmin_avg, label='Predicted Avg Tmin', marker='x', linestyle='--')
plt.ylabel('Avg Tmin (°C)')
plt.legend()

# Plot the average Tmax
plt.subplot(3, 1, 2)
plt.plot(X_years, y_tmax_avg, label='Average Historical Tmax', marker='o')
plt.plot(future_years, predictions_tmax_avg, label='Predicted Avg Tmax', marker='x', linestyle='--')
plt.ylabel('Avg Tmax (°C)')
plt.legend()

# Plot the average Prcp
plt.subplot(3, 1, 3)
plt.plot(X_years, y_prcp_avg, label='Average Historical Prcp', marker='o')
plt.plot(future_years, predictions_prcp_avg, label='Predicted Avg Prcp', marker='x', linestyle='--')
plt.xlabel('Year')
plt.ylabel('Avg Prcp (mm)')
plt.legend()

# Improve spacing and layout
plt.tight_layout()
plt.show()

## I use the average for each year for training data.

import pandas as pd
import matplotlib.dates as mdates

# Convert numpy arrays to pandas Series with the dates as the index
tmin_series = pd.Series(y_tmin, index=pd.to_datetime(X_dates))
tmax_series = pd.Series(y_tmax, index=pd.to_datetime(X_dates))
prcp_series = pd.Series(y_prcp, index=pd.to_datetime(X_dates))

# Calculate the moving average with a window of 4 (quarterly data, so a window size of 4 covers one year)
tmin_moving_avg = tmin_series.rolling(window=4).mean()
tmax_moving_avg = tmax_series.rolling(window=4).mean()
prcp_moving_avg = prcp_series.rolling(window=4).mean()

# Now we can add the moving average plots to our existing plot code
plt.figure(figsize=(14, 10))

# TMIN Plot
plt.subplot(3, 1, 1)
plt.plot(tmin_series.index, tmin_series, label='Historical Tmin', marker='o', linestyle='-')
plt.plot(future_dates_dt, predictions_tmin, label='Predicted Tmin', marker='x', linestyle='--')
plt.plot(tmin_moving_avg.index, tmin_moving_avg, label='Tmin Moving Average', color='orange', linestyle='-')
plt.ylabel('Tmin (°C)')
plt.legend()
plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))

# TMAX Plot
plt.subplot(3, 1, 2)
plt.plot(tmax_series.index, tmax_series, label='Historical Tmax', marker='o', linestyle='-')
plt.plot(future_dates_dt, predictions_tmax, label='Predicted Tmax', marker='x', linestyle='--')
plt.plot(tmax_moving_avg.index, tmax_moving_avg, label='Tmax Moving Average', color='orange', linestyle='-')
plt.ylabel('Tmax (°C)')
plt.legend()
plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))

# PRCP Plot
plt.subplot(3, 1, 3)
plt.plot(prcp_series.index, prcp_series, label='Historical Prcp', marker='o', linestyle='-')
plt.plot(future_dates_dt, predictions_prcp, label='Predicted Prcp', marker='x', linestyle='--')
plt.plot(prcp_moving_avg.index, prcp_moving_avg, label='Prcp Moving Average', color='orange', linestyle='-')
plt.xlabel('Date')
plt.ylabel('Prcp (mm)')
plt.legend()
plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))

plt.tight_layout()
plt.show()

output_csv = 'output.csv'

def write_to_csv(result, output_csv):

      writer = csv.DictWriter(csvfile, fieldnames=result.keys())
      writer.writeheader()
      writer.writerow(result)

"""Generate Random Coordinates"""

# Define coordinates for the bounding box of Arizona
minLon = -111.931
minLat = 31.332
maxLon = -109.045
maxLat = 37.004

# Create a bounding box geometry for Arizona
bounding_box = ee.Geometry.Rectangle([minLon, minLat, maxLon, maxLat])

# Generate random points within the filtered bounding box
random_points = ee.FeatureCollection.randomPoints(region=bounding_box, points=10)

# Get the coordinates of the random points
coordinates = random_points.geometry().coordinates().getInfo()

# Print the coordinates
print("Coordinates of Random Points:")

columns = ['lat', 'lon', 'irrigation_result', 'tmin', 'tmax', 'prcp', 'cropland', 'elevation_result']
with open(output_csv, 'w', newline='') as csvfile:
    writer = csv.DictWriter(csvfile, fieldnames=columns)
    writer.writeheader()
    for coord in coordinates:
        result = get_results(coord)
        result['lon'] = coord[0]
        result['lat'] = coord[1]
        writer.writerow(result)

